// Code generated by bpf2go; DO NOT EDIT.
//go:build (mips || mips64 || ppc64 || s390x) && linux

package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type netflowFlowKey struct {
	SrcIp    uint32
	DstIp    uint32
	SrcPort  uint16
	DstPort  uint16
	Protocol uint8
	_        [3]byte
}

type netflowFlowMetrics struct {
	Packets uint64
	Bytes   uint64
	StartTs uint64
	LastTs  uint64
}

// loadNetflow returns the embedded CollectionSpec for netflow.
func loadNetflow() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_NetflowBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load netflow: %w", err)
	}

	return spec, err
}

// loadNetflowObjects loads netflow and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*netflowObjects
//	*netflowPrograms
//	*netflowMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadNetflowObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadNetflow()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// netflowSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type netflowSpecs struct {
	netflowProgramSpecs
	netflowMapSpecs
	netflowVariableSpecs
}

// netflowProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type netflowProgramSpecs struct {
	TcEgressFunc  *ebpf.ProgramSpec `ebpf:"tc_egress_func"`
	TcIngressFunc *ebpf.ProgramSpec `ebpf:"tc_ingress_func"`
}

// netflowMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type netflowMapSpecs struct {
	FlowTable      *ebpf.MapSpec `ebpf:"flow_table"`
	NetflowRingbuf *ebpf.MapSpec `ebpf:"netflow_ringbuf"`
}

// netflowVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type netflowVariableSpecs struct {
}

// netflowObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadNetflowObjects or ebpf.CollectionSpec.LoadAndAssign.
type netflowObjects struct {
	netflowPrograms
	netflowMaps
	netflowVariables
}

func (o *netflowObjects) Close() error {
	return _NetflowClose(
		&o.netflowPrograms,
		&o.netflowMaps,
	)
}

// netflowMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadNetflowObjects or ebpf.CollectionSpec.LoadAndAssign.
type netflowMaps struct {
	FlowTable      *ebpf.Map `ebpf:"flow_table"`
	NetflowRingbuf *ebpf.Map `ebpf:"netflow_ringbuf"`
}

func (m *netflowMaps) Close() error {
	return _NetflowClose(
		m.FlowTable,
		m.NetflowRingbuf,
	)
}

// netflowVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadNetflowObjects or ebpf.CollectionSpec.LoadAndAssign.
type netflowVariables struct {
}

// netflowPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadNetflowObjects or ebpf.CollectionSpec.LoadAndAssign.
type netflowPrograms struct {
	TcEgressFunc  *ebpf.Program `ebpf:"tc_egress_func"`
	TcIngressFunc *ebpf.Program `ebpf:"tc_ingress_func"`
}

func (p *netflowPrograms) Close() error {
	return _NetflowClose(
		p.TcEgressFunc,
		p.TcIngressFunc,
	)
}

func _NetflowClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed netflow_bpfeb.o
var _NetflowBytes []byte
